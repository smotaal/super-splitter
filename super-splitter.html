
<!--
`super-splitter` provides a split bar and dragging on the split bar
will resize the sibling element.  Use its `direction` property to indicate
which sibling element to be resized and the orientation.  Usually you would want
to use `super-splitter` along with flex layout so that the other sibling
element can be _flexible_.

Example:
    <div horizontal layout>
      <div>left</div>
      <core-splitter direction="left"></core-splitter>
      <div flex>right</div>
    </div>

In the above example, dragging the splitter will resize the _left_ element.  And
since the parent container is a flexbox and the _right_ element has
`flex`, the _right_ element will be auto-resized.
For horizontal splitter set `direction` to `up` or `down`.

Example:
    <div vertical layout>
      <div>top</div>
      <core-splitter direction="up"></core-splitter>
      <div flex>bottom</div>
    </div>

@demo demo/index.html
@hero hero.svg
-->


<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />
<dom-module id="super-splitter">
  <template>
    <style>
      :host {
        display: block;
        width: 12px;
        background: #efefef url(handle.svg) no-repeat center;
        box-shadow: inset 0 0 2px 1px #ccc;
        cursor: col-resize;
      }

      :host(.horizontal) {
        width: auto;
        height: 12px;
        cursor: row-resize;
        background-image: url(handle-h.svg);
      }

      :host(:hover, :active) {
        background-color: #ddd;
      }

    </style>
  </template>

  <script>
    Polymer({

      is: 'super-splitter',
      behaviors: [
        Polymer.IronResizableBehavior
      ],

      properties: {
        /**
        * Possible values are `left`, `right`, `up` and `down`.
        *
        * @attribute direction
        * @type string
        * @default 'left'
        */
        direction: {
          type: String,
          value: 'left',
        },
        /**
        * * Minimum width to which the splitter target can be sized, e.g.
        * `minSize="100px"`
        */
        minSize: {
          type: String,
          value: ''
        },
        /**
        * Lock the split bar so it can't be dragged.
        */
        locked: {
          type: Boolean,
          value: false
        },
      /**
      * By default the parent and siblings of the splitter are set to overflow hidden. This helps
      * avoid elements bleeding outside the splitter regions. Set this property to true to allow
      * these elements to overflow.
      *
      * @attribute allowOverflow
      * @type boolean
      * @default false
      */
        allowOverflow: {
          type: Boolean,
          value: false
        },
        // Listen for resize requests on parent, since splitter is peer to resizables
        resizerIsPeer: {
          type: Boolean,
          value: true
        }
      },

      listeners: {
        'track': 'handleTrack',
        'down': 'preventSelection'
      },

      ready: function () {
        if (!this.allowOverflow) {
          this.parentNode.style.overflow = this.nextElementSibling.style.overflow =
              this.previousElementSibling.style.overflow = 'hidden';
        }

        this.directionChanged();
        this.behaviors.map(b => b.ready ? b.ready.call(this) : null)
      },

      directionChanged: function() {
        this.isNext = this.direction === 'right' || this.direction === 'down';
        this.horizontal = this.direction === 'up' || this.direction === 'down';
        this.update();
      },

      update: function() {
        this.target = this.isNext ? this.nextElementSibling : this.previousElementSibling;
        this.dimension = this.horizontal ? 'height' : 'width';
        this.classList.toggle('horizontal', this.horizontal);
      },

      attached: function () {
        this.behaviors.map(b => b.attached ? b.attached.call(this) : null)
      },

      created: function () {
        this.behaviors.map(b => b.created ? b.created.call(this) : null)
      },

      detached: function () {
        this.behaviors.map(b => b.detached ? b.detached.call(this) : null)
      },

      handleTrack: function (e) {
        switch (e.detail.state){
          case 'start': {
            this.update();
            this.size = parseInt(getComputedStyle(this.target)[this.dimension]);
          }

          case 'track': {
            if (this.locked) {
              return;
            }
            var d = e.detail[this.horizontal ? 'dy' : 'dx'];
            this.target.style[this.dimension] =
                this.size + (this.isNext ? -d : d) + 'px';
            this.notifyResize();
          }

          case 'end': {

          }
        }
      },

      /**
       * Prevents selection of text on nearby elements.
       * @param  {Object} e The event Object.
       * @return {null}   null
       */
      preventSelection: function(e) {
        e.preventDefault();
      }

    });
  </script>
</dom-module>
